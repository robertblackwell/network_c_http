#ifndef c_tests_test_echo_listener_h
#define c_tests_test_echo_listener_h


#include <assert.h>
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
             /* See feature_test_macros(7) */
#include <fcntl.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>
#include <rbl/unittest.h>
#include <src/common/utils.h>
#include <src/common/socket_functions.h>
#include <src/sync/sync_client.h>
#include <kqueue_runloop/runloop.h>
#include <kqueue_runloop/runloop_internal.h>

#include <rbl/check_tag.h>
#include "stream_ctx.h"
#define Ctx_TAG "LCTX"
// #define RDCTX_TAG "RDCTX"
typedef int socket_handle_t;

void postable_reader_start(RunloopRef rl, void* arg);


/**
 * Listener is an object that 
 * -    listens for an accepts connections, on a designated port.
 * -    holds accepted connection in a list.
 * -    terminates closing all connections after a specified period.
 * -    the timeinterval over which the object accepts connections is
 *      controlled by a w_timer
 * 
 */
struct Server_s {
    RBL_DECLARE_TAG;
    int                     l_state;
    int                     port;
    const char*             host;
    socket_handle_t         listening_socket_fd;
    RunloopRef              runloop_ref;
    RunloopEventRef         rl_event;
    int                     listen_count;
    int                     accept_count;
    int                     max_accept_count;
    int                     id;
    StreamTable             stream_table;
    RBL_DECLARE_END_TAG;
};
typedef struct  Server_s TestServer, *ServerRef;


ServerRef listener_ctx_new(int listen_fd, int id, RunloopRef rl);
void listener_ctx_init(ServerRef sref, int listen_fd, int id, RunloopRef rl);

void listener_ctx_free(ServerRef sref);
void listener_ctx_run(ServerRef sref);

int local_create_bound_socket(int port, const char* host);


#endif